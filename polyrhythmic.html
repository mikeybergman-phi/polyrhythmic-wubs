<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Low‑End Polyrhythmic Wubs — Generative Engine</title>
  <style>
    :root{ --bg:#0a0d13; --pane:#0f151f; --line:#182132; --fg:#e7eaee; --muted:#96a2b4; }
    html,body{height:100%;margin:0}
    body{background:var(--bg);color:var(--fg);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    #app{position:fixed;inset:0;display:grid;grid-template-rows:auto auto 1fr}
    header{display:flex;gap:12px;align-items:center;padding:10px 12px;border-bottom:1px solid var(--line);flex-wrap:wrap}
    h1{font-size:15px;margin:0;font-weight:600}
    .btn{background:#121a1f;border:1px solid var(--line);color:var(--fg);padding:8px 12px;border-radius:10px;cursor:pointer}
    .grid{display:grid;gap:10px;padding:10px;grid-template-columns:repeat(3,minmax(280px,1fr))}
    .card{background:var(--pane);border:1px solid var(--line);border-radius:14px;padding:12px}
    .card h3{margin:0 0 8px 0;font-size:13px}
    label{font-size:12px;color:var(--muted);display:grid;grid-template-columns:150px 1fr 52px;align-items:center;gap:8px;margin:4px 0}
    input[type=range]{width:100%}
    select{background:#101625;color:var(--fg);border:1px solid var(--line);border-radius:8px;padding:6px}
    canvas{width:100%;height:100%;display:block}
    .small{font-size:11px;color:#9fb0c8}
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Low‑End Polyrhythmic Wubs</h1>
      <button class="btn" id="start">Start</button>
      <label>Tempo (BPM)
        <input id="bpm" type="range" min="30" max="160" step="1" value="80"/>
        <span id="bpmVal">80</span>
      </label>
      <label>Root (Hz)
        <input id="root" type="range" min="30" max="120" step="1" value="55"/>
        <span id="rootVal">55</span>
      </label>
      <label>Reverb Mix
        <input id="rev" type="range" min="0" max="0.5" step="0.01" value="0.12"/>
        <span id="revVal">0.12</span>
      </label>
      <label>Master
        <input id="master" type="range" min="0" max="1" step="0.01" value="0.9"/>
        <span id="masterVal">0.90</span>
      </label>
      <label>Evolve
        <input id="evolve" type="checkbox"/>
        <span class="small">slow random walk</span>
      </label>
      <label>Evolve Rate (s)
        <input id="evoRate" type="range" min="2" max="30" step="1" value="6"/>
        <span id="evoRateVal">6</span>
      </label>
      <label>Evolve Depth
        <input id="evoDepth" type="range" min="0" max="1" step="0.01" value="0.35"/>
        <span id="evoDepthVal">0.35</span>
      </label>
      <button class="btn" id="rndNow">Randomize Now</button>
    </header>

    <div class="grid">
      <div class="card">
        <h3>SUB — foundation</h3>
        <label>Steps <input id="subSteps" type="range" min="3" max="16" value="8"/><span id="subStepsVal">8</span></label>
        <label>Pulses <input id="subPulses" type="range" min="1" max="16" value="3"/><span id="subPulsesVal">3</span></label>
        <label>Volume <input id="subVol" type="range" min="0" max="1" step="0.01" value="0.8"/><span id="subVolVal">0.80</span></label>
        <label>Drive <input id="subDrive" type="range" min="0" max="1" step="0.01" value="0.15"/><span id="subDriveVal">0.15</span></label>
        <label>Decay (s) <input id="subDecay" type="range" min="0.05" max="1.2" step="0.01" value="0.45"/><span id="subDecayVal">0.45</span></label>
        <label>Glide (s) <input id="subGlide" type="range" min="0" max="0.3" step="0.005" value="0.02"/><span id="subGlideVal">0.02</span></label>
        <label>Wave
          <select id="subWave"><option>sine</option><option selected>triangle</option><option>sawtooth</option></select>
          <span></span>
        </label>
      </div>

      <div class="card">
        <h3>WUB A — lowpass wobble</h3>
        <label>Steps <input id="aSteps" type="range" min="3" max="16" value="7"/><span id="aStepsVal">7</span></label>
        <label>Pulses <input id="aPulses" type="range" min="1" max="16" value="5"/><span id="aPulsesVal">5</span></label>
        <label>Volume <input id="aVol" type="range" min="0" max="1" step="0.01" value="0.75"/><span id="aVolVal">0.75</span></label>
        <label>Base Cutoff (Hz) <input id="aCut" type="range" min="50" max="1200" step="1" value="220"/><span id="aCutVal">220</span></label>
        <label>Depth (oct) <input id="aDepth" type="range" min="0" max="4" step="0.01" value="2.0"/><span id="aDepthVal">2.00</span></label>
        <label>Resonance Q <input id="aQ" type="range" min="0.1" max="20" step="0.1" value="7"/><span id="aQVal">7.0</span></label>
        <label>LFO Rate <input id="aRate" type="range" min="0.05" max="12" step="0.01" value="2.2"/><span id="aRateVal">2.20Hz</span></label>
        <label>Sync Division
          <select id="aDiv">
            <option value="free" selected>Free</option>
            <option>1/1</option><option>1/2</option><option>1/3</option><option>1/4</option>
            <option>1/6</option><option>1/8</option><option>1/12</option><option>1/16</option>
            <option>1/8T</option><option>1/16T</option>
          </select>
          <span class="small">tempo‑sync</span>
        </label>
        <label>Drive <input id="aDrive" type="range" min="0" max="1" step="0.01" value="0.25"/><span id="aDriveVal">0.25</span></label>
        <label>Stereo Width <input id="aWidth" type="range" min="0" max="1" step="0.01" value="0.4"/><span id="aWidthVal">0.40</span></label>
      </div>

      <div class="card">
        <h3>WUB B — bandpass growl</h3>
        <label>Steps <input id="bSteps" type="range" min="3" max="16" value="9"/><span id="bStepsVal">9</span></label>
        <label>Pulses <input id="bPulses" type="range" min="1" max="16" value="4"/><span id="bPulsesVal">4</span></label>
        <label>Volume <input id="bVol" type="range" min="0" max="1" step="0.01" value="0.6"/><span id="bVolVal">0.60</span></label>
        <label>Center (Hz) <input id="bCenter" type="range" min="80" max="1800" step="1" value="320"/><span id="bCenterVal">320</span></label>
        <label>Width (oct) <input id="bWidth" type="range" min="0.1" max="4" step="0.01" value="1.4"/><span id="bWidthVal">1.40</span></label>
        <label>LFO Rate <input id="bRate" type="range" min="0.05" max="12" step="0.01" value="3.3"/><span id="bRateVal">3.30Hz</span></label>
        <label>Sync Division
          <select id="bDiv">
            <option value="free" selected>Free</option>
            <option>1/1</option><option>1/2</option><option>1/3</option><option>1/4</option>
            <option>1/6</option><option>1/8</option><option>1/12</option><option>1/16</option>
            <option>1/8T</option><option>1/16T</option>
          </select>
          <span class="small">tempo‑sync</span>
        </label>
        <label>Drive <input id="bDrive" type="range" min="0" max="1" step="0.01" value="0.35"/><span id="bDriveVal">0.35</span></label>
        <label>Stereo Width <input id="bWidthStereo" type="range" min="0" max="1" step="0.01" value="0.55"/><span id="bWidthStereoVal">0.55</span></label>
      </div>
    </div>

    <div class="card" style="margin:0 10px 10px 10px;padding:0;overflow:hidden">
      <canvas id="viz"></canvas>
    </div>
  </div>

<script>
// helpers
const $ = id => document.getElementById(id);
const setVal = (id, v, s='')=>($(id).textContent = `${(typeof v==='number'? (Math.round(v*100)/100): v)}${s}`);
const clamp=(n,a,b)=>Math.min(b,Math.max(a,n));

// ====== Audio Init ======
let ctx, master, ana, conv, revGain, started=false;
function makeReverbImpulse(ctx, dur=2.2, decay=2.6){
  const len = Math.floor(ctx.sampleRate*dur); const buf = ctx.createBuffer(2,len,ctx.sampleRate);
  for(let ch=0; ch<2; ch++){ const d=buf.getChannelData(ch); for(let i=0;i<len;i++){ const t=i/len; d[i]=(Math.random()*2-1)*Math.pow(1-t,decay);} }
  return buf;
}
function waveshaper(amount){
  const n=44100, curve=new Float32Array(n); const k=amount*100; for(let i=0;i<n;i++){ const x=i*2/n-1; curve[i]=(1+k)*x/(1+k*Math.abs(x)); } return curve;
}
function init(){
  if(started) return; started=true;
  ctx = new (window.AudioContext||window.webkitAudioContext)();
  master = ctx.createGain(); master.gain.value=parseFloat($("master").value);
  ana = ctx.createAnalyser(); ana.fftSize=1024; master.connect(ana); master.connect(ctx.destination);
  conv = ctx.createConvolver(); conv.buffer=makeReverbImpulse(ctx);
  revGain = ctx.createGain(); revGain.gain.value=parseFloat($("rev").value); conv.connect(revGain); revGain.connect(ctx.destination);
  master.connect(conv);
}

// ====== Rhythm (Euclidean) ======
function euclid(steps, pulses){
  steps=Math.max(1,Math.floor(steps)); pulses=clamp(Math.floor(pulses),0,steps);
  const pat=new Array(steps).fill(0); let bucket=0; for(let i=0;i<steps;i++){ bucket+=pulses; if(bucket>=steps){ bucket-=steps; pat[i]=1; } }
  return pat;
}

// ====== Scheduler ======
let tick=0, nextTime=0, timer=null;
function run(){ if(timer) return; nextTime=ctx.currentTime+0.05; timer=setInterval(schedule, 25); }
function schedule(){
  const sixteenth = 60/parseInt($("bpm").value,10)/4;
  while(nextTime < ctx.currentTime + 0.1){ trigger(nextTime); nextTime += sixteenth; tick++; }
}

// ====== Voices ======
class SubVoice{
  constructor(){
    this.pattern = euclid(parseInt($("subSteps").value,10), parseInt($("subPulses").value,10));
    this.step=-1; this.port= parseFloat($("subGlide").value);
    this.osc = ctx.createOscillator(); this.osc.type=$("subWave").value; this.osc.frequency.value=parseFloat($("root").value);
    this.gain = ctx.createGain(); this.gain.gain.value=0.0001;
    this.shaper = ctx.createWaveShaper(); this.shaper.curve = waveshaper(parseFloat($("subDrive").value));
    this.osc.connect(this.shaper); this.shaper.connect(this.gain); this.gain.connect(master); this.osc.start();
  }
  refresh(){ this.pattern=euclid(parseInt($("subSteps").value,10), parseInt($("subPulses").value,10)); this.port=parseFloat($("subGlide").value); this.osc.type=$("subWave").value; this.shaper.curve=waveshaper(parseFloat($("subDrive").value)); }
  tick(time){
    if(++this.step>=this.pattern.length) this.step=0;
    if(this.pattern[this.step]){
      const base=parseFloat($("root").value); const note = base * (Math.random()<0.2? 2:1);
      const now=time; const cur=this.osc.frequency.value; const glide=this.port;
      this.osc.frequency.cancelScheduledValues(now);
      this.osc.frequency.setValueAtTime(cur, now);
      this.osc.frequency.linearRampToValueAtTime(note, now+glide);
      const v=parseFloat($("subVol").value); const d=parseFloat($("subDecay").value);
      this.gain.gain.cancelScheduledValues(now);
      this.gain.gain.setValueAtTime(this.gain.gain.value||0.0001, now);
      this.gain.gain.linearRampToValueAtTime(v, now+0.01);
      this.gain.gain.exponentialRampToValueAtTime(0.0001, now+d);
    }
  }
}

class WubVoice{
  constructor(kind){
    this.kind = kind; const pre = kind==='A' ? 'a' : 'b';
    this.pre=pre; this.pattern=euclid(parseInt($(pre+"Steps").value,10), parseInt($(pre+"Pulses").value,10)); this.step=-1;
    this.oscL = ctx.createOscillator(); this.oscR = ctx.createOscillator();
    this.oscL.type='sawtooth'; this.oscR.type='sawtooth';
    this.oscL.frequency.value=parseFloat($("root").value)*2; this.oscR.frequency.value=parseFloat($("root").value)*2.01;
    this.lGain = ctx.createGain(); this.rGain = ctx.createGain(); this.lGain.gain.value=0.0001; this.rGain.gain.value=0.0001;
    this.filterL = ctx.createBiquadFilter(); this.filterR = ctx.createBiquadFilter();
    this.filterL.type = (kind==='A')?'lowpass':'bandpass'; this.filterR.type=this.filterL.type;
    this.lfo = ctx.createOscillator(); this.lfo.type='sine'; this.lfo.frequency.value = parseFloat($(pre+"Rate").value);
    this.lfoGain = ctx.createGain(); this.lfoGain.gain.value=1;
    this.drive = ctx.createWaveShaper(); this.drive.curve = waveshaper(parseFloat($(pre+"Drive").value));
    this.merge = ctx.createChannelMerger(2); this.split = ctx.createChannelSplitter(2); this.panner = ctx.createStereoPanner();
    this.lfo.connect(this.lfoGain);
    this.lfoGain.connect(this.filterL.frequency); this.lfoGain.connect(this.filterR.frequency);
    this.oscL.connect(this.filterL); this.oscR.connect(this.filterR);
    this.filterL.connect(this.drive); this.filterR.connect(this.drive);
    this.drive.connect(this.split);
    this.split.connect(this.lGain,0); this.split.connect(this.rGain,1);
    this.lGain.connect(this.panner); this.rGain.connect(this.panner);
    this.panner.connect(master);
    this.oscL.start(); this.oscR.start(); this.lfo.start();
    this.refresh();
  }
  divToHz(div){
    const bpm=parseInt($("bpm").value,10); const q=bpm/60; const map={'1/1':q,'1/2':q*2,'1/3':q*3,'1/4':q*4,'1/6':q*6,'1/8':q*8,'1/12':q*12,'1/16':q*16,'1/8T':q*12,'1/16T':q*24};
    return map[div]||parseFloat($(this.pre+"Rate").value);
  }
  refresh(){
    const pre=this.pre; this.pattern=euclid(parseInt($(pre+"Steps").value,10), parseInt($(pre+"Pulses").value,10));
    const root=parseFloat($("root").value);
    this.oscL.frequency.setValueAtTime(root*2, ctx.currentTime);
    this.oscR.frequency.setValueAtTime(root*2.01, ctx.currentTime);
    const width=parseFloat($(pre+(this.kind==='A'?"Width":"WidthStereo")).value);
    this.panner.pan.value = width*0.8 - 0.4;
    if(this.kind==='A'){
      const base=parseFloat($("aCut").value); const depthOct=parseFloat($("aDepth").value);
      const min=base/Math.pow(2,depthOct); const max=base*Math.pow(2,depthOct*0.25);
      this.filterL.frequency.setValueAtTime(base, ctx.currentTime);
      this.filterR.frequency.setValueAtTime(base, ctx.currentTime);
      this.filterL.Q.value=parseFloat($("aQ").value);
      this.filterR.Q.value=parseFloat($("aQ").value);
      this.lfoGain.gain.value = (max-min)/2;
      this.lfo.frequency.value = ($("aDiv").value==='free')? parseFloat($("aRate").value) : this.divToHz($("aDiv").value);
      const offset = (max+min)/2 - base;
      this.filterL.frequency.setValueAtTime(base+offset, ctx.currentTime);
      this.filterR.frequency.setValueAtTime(base+offset, ctx.currentTime);
    } else {
      const center=parseFloat($("bCenter").value); const widthOct=parseFloat($("bWidth").value);
      const min=center/Math.pow(2,widthOct*0.5); const max=center*Math.pow(2,widthOct*0.5);
      this.filterL.frequency.setValueAtTime(center, ctx.currentTime);
      this.filterR.frequency.setValueAtTime(center, ctx.currentTime);
      this.filterL.Q.value=8; this.filterR.Q.value=8;
      this.lfoGain.gain.value=(max-min)/2; this.lfo.frequency.value = ($("bDiv").value==='free')? parseFloat($("bRate").value) : this.divToHz($("bDiv").value);
      const offset=(max+min)/2 - center; this.filterL.frequency.setValueAtTime(center+offset, ctx.currentTime); this.filterR.frequency.setValueAtTime(center+offset, ctx.currentTime);
    }
    this.drive.curve = waveshaper(parseFloat($(this.pre+"Drive").value));
  }
  tick(time){
    if(++this.step>=this.pattern.length) this.step=0;
    if(this.pattern[this.step]){
      const vol=parseFloat($(this.pre+"Vol").value);
      const gL=this.lGain.gain, gR=this.rGain.gain; const atk=0.01, rel=0.35;
      gL.cancelScheduledValues(time); gR.cancelScheduledValues(time);
      gL.setValueAtTime(0.0001,time); gR.setValueAtTime(0.0001,time);
      gL.exponentialRampToValueAtTime(vol, time+atk);
      gR.exponentialRampToValueAtTime(vol, time+atk);
      gL.exponentialRampToValueAtTime(0.0001, time+rel);
      gR.exponentialRampToValueAtTime(0.0001, time+rel);
    }
  }
}

let sub, wubA, wubB;
function build(){ sub=new SubVoice(); wubA=new WubVoice('A'); wubB=new WubVoice('B'); }
function trigger(time){ sub.tick(time); wubA.tick(time); wubB.tick(time); }

// ====== Visuals ======
const cvs=$("viz"), c2=cvs.getContext('2d');
function resize(){ cvs.width=cvs.clientWidth*devicePixelRatio; cvs.height=cvs.clientHeight*devicePixelRatio; }
window.addEventListener('resize', resize); resize();
function draw(){ requestAnimationFrame(draw); if(!ana) return; const W=cvs.width, H=cvs.height; c2.fillStyle='rgba(9,12,18,0.2)'; c2.fillRect(0,0,W,H);
  const td=new Uint8Array(ana.frequencyBinCount); ana.getByteTimeDomainData(td);
  const cx=W/2, cy=H/2, R=Math.min(W,H)*0.33; c2.beginPath(); for(let i=0;i<256;i++){ const a=i/256*Math.PI*2; const amp=td[i]/255; const r=R*(0.7+0.4*amp); const x=cx+Math.cos(a)*r, y=cy+Math.sin(a)*r; if(i===0) c2.moveTo(x,y); else c2.lineTo(x,y);} c2.closePath(); c2.strokeStyle='rgba(120,255,214,0.85)'; c2.lineWidth=2*devicePixelRatio; c2.stroke();
  const fb=new Uint8Array(ana.frequencyBinCount); ana.getByteFrequencyData(fb); const bars=64; const bw=W/bars; for(let i=0;i<bars;i++){ const v=fb[i]/255; const h=v*H*0.35; c2.fillStyle=`rgba(${40+v*80},${120+v*100},${200},0.9)`; c2.fillRect(i*bw, H-h, bw-2, h); }
}
requestAnimationFrame(draw);

// ====== Top controls wiring ======
["bpm","root","rev","master"].forEach(id=>$(id).addEventListener('input',e=>{
  setVal(id+"Val", parseFloat(e.target.value));
  if(id==='master'&&master) master.gain.value=parseFloat(e.target.value);
  if(id==='rev'&&revGain) revGain.gain.value=parseFloat(e.target.value);
  if((id==='bpm'||id==='root')&&started){ wubA.refresh(); wubB.refresh(); }
}));

// Voice controls
["subSteps","subPulses","subVol","subDrive","subDecay","subGlide","subWave"].forEach(id=>$(id).addEventListener('input',()=>{ setVal(id+"Val", $(id).value); if(started){ sub.refresh(); }}));
["aSteps","aPulses","aVol","aCut","aDepth","aQ","aRate","aDiv","aDrive","aWidth"].forEach(id=>$(id).addEventListener('input',()=>{ setVal(id+"Val", $(id).value, id.includes('Rate')?'Hz':''); if(started){ wubA.refresh(); }}));
["bSteps","bPulses","bVol","bCenter","bWidth","bRate","bDiv","bDrive","bWidthStereo"].forEach(id=>$(id).addEventListener('input',()=>{ setVal(id+"Val", $(id).value, id.includes('Rate')?'Hz':''); if(started){ wubB.refresh(); }}));

// Start/Stop
$("start").addEventListener('click', async ()=>{
  init(); if(ctx.state==='suspended') await ctx.resume();
  if($("start").textContent==='Start'){ $("start").textContent='Stop'; build(); run(); }
  else { $("start").textContent='Start'; clearInterval(timer); timer=null; tick=0; }
});

// ====== Evolution (Randomizer) ======
function setInput(id, value){ const el=$(id); if(!el) return; el.value = (typeof value==='number')? value : value; el.dispatchEvent(new Event('input')); }
function nudgeFloat(id, amt, min, max, step){ const el=$(id); if(!el) return; const s = step || (el.step? parseFloat(el.step): 0.01); let v=parseFloat(el.value); v += (Math.random()*2-1)*amt; v = clamp(v, min, max); v = Math.round(v/s)*s; setInput(id, v); }
function nudgeInt(id, amt, min, max){ const el=$(id); if(!el) return; let v=parseInt(el.value,10); v += ((Math.random()*2-1)*amt)|0; v = clamp(v, min, max)|0; setInput(id, v); }
function pick(arr){ return arr[(Math.random()*arr.length)|0]; }

let evoTimer=null;
function evoStep(){
  const depth=parseFloat($("evoDepth").value)||0.3;
  const which = Math.random();
  if(which<0.2){
    nudgeInt('bpm', 1, 40, 140);
    if(Math.random()<0.4) nudgeFloat('root', 1*depth*10, 30, 120, 1);
  } else if(which<0.45){
    if(Math.random()<0.5) nudgeInt('subPulses', 1, 1, parseInt($("subSteps").value,10));
    else nudgeInt('subSteps', 1, 3, 16);
    if(Math.random()<0.6) nudgeFloat('subDrive', 0.15*depth, 0, 1, 0.01);
    if(Math.random()<0.6) nudgeFloat('subDecay', 0.15*depth, 0.05, 1.2, 0.01);
    if(Math.random()<0.4) nudgeFloat('subGlide', 0.05*depth, 0, 0.3, 0.005);
  } else if(which<0.7){
    if(Math.random()<0.5) nudgeInt('aPulses', 1, 1, parseInt($("aSteps").value,10));
    else nudgeInt('aSteps', 1, 3, 16);
    if(Math.random()<0.6) nudgeFloat('aCut', 80*depth, 50, 1200, 1);
    if(Math.random()<0.6) nudgeFloat('aDepth', 0.35*depth, 0, 4, 0.01);
    if(Math.random()<0.4) nudgeFloat('aQ', 1.0*depth, 0.1, 20, 0.1);
    if(Math.random()<0.5){
      if($("aDiv").value==='free') nudgeFloat('aRate', 0.6*depth, 0.05, 12, 0.01);
      else if(Math.random()<0.25) setInput('aDiv', 'free');
    } else if(Math.random()<0.2){
      const opts=['1/1','1/2','1/3','1/4','1/6','1/8','1/12','1/16','1/8T','1/16T'];
      setInput('aDiv', pick(opts));
    }
    if(Math.random()<0.5) nudgeFloat('aDrive', 0.15*depth, 0, 1, 0.01);
    if(Math.random()<0.4) nudgeFloat('aWidth', 0.2*depth, 0, 1, 0.01);
  } else {
    if(Math.random()<0.5) nudgeInt('bPulses', 1, 1, parseInt($("bSteps").value,10));
    else nudgeInt('bSteps', 1, 3, 16);
    if(Math.random()<0.6) nudgeFloat('bCenter', 120*depth, 80, 1800, 1);
    if(Math.random()<0.6) nudgeFloat('bWidth', 0.3*depth, 0.1, 4, 0.01);
    if(Math.random()<0.5){
      if($("bDiv").value==='free') nudgeFloat('bRate', 0.6*depth, 0.05, 12, 0.01);
      else if(Math.random()<0.25) setInput('bDiv', 'free');
    } else if(Math.random()<0.2){
      const opts=['1/1','1/2','1/3','1/4','1/6','1/8','1/12','1/16','1/8T','1/16T'];
      setInput('bDiv', pick(opts));
    }
    if(Math.random()<0.5) nudgeFloat('bDrive', 0.15*depth, 0, 1, 0.01);
    if(Math.random()<0.4) nudgeFloat('bWidthStereo', 0.2*depth, 0, 1, 0.01);
  }
}
function startEvo(){ stopEvo(); const ms = parseInt($("evoRate").value,10)*1000; evoTimer = setInterval(evoStep, ms); }
function stopEvo(){ if(evoTimer){ clearInterval(evoTimer); evoTimer=null; } }

$("evolve").addEventListener('change', e=>{ if(e.target.checked){ startEvo(); } else { stopEvo(); } });
$("evoRate").addEventListener('input', e=>{ $("evoRateVal").textContent=e.target.value; if(evoTimer) startEvo(); });
$("evoDepth").addEventListener('input', e=>{ $("evoDepthVal").textContent=parseFloat(e.target.value).toFixed(2); });
$("rndNow").addEventListener('click', ()=>{ for(let i=0;i<8;i++) evoStep(); });
</script>
</body>
</html>